1: 建议数据类型写成一文件或inc(用{$i xx.inc}引用
   而不是每个单元进行：
   {$if CompilerVersion <= 23}
type
     NativeUInt = Cardinal;
     IntPtr = Cardinal;
{$ifend}
-------------------------------------------------------------------------------------------------------------------------------------------------
2：iocpEngine.pas

a: 
  所有使用PostQueuedCompletionStatus调用，必须确认它的返回值返回true，否则失败了，如果有overlapeed，是不是有泄露？
   post（还有postMessage函数也是）是有机率失败的，请注意
------------------
b: TIocpEngine.safeStop;
我更觉得应该写成：
for i := 0 to FWorkerList.count - 1 do
  TThread(FWOrkerList[i]).Terminate;
  
while FWorkerList.Count > 0 do
[
  FIocpCore.postIOExitRequest();
  sleep(10); 
]

然后在TIocpWorker.OnTerminate事件中进行操作FWorkerList.Remove(Thread),使FWorkerList.count--
------------------
c: TIocpCore.bind2IOCPHandle
这个调用，如果result =0，一般情况下是因为重复绑定的问题，如果使用acceptex+disconnect进行socket池化，则第二次绑定会异常。。。

------------------
d: 我有个习惯：高频调用类函数，一般不用虚函数
   比如：TIocpRequest.HandleResponse
   一般用回调，如果没回调，在start时候，就提示错误。
   这个你就看看好了
   
-------------------------------------------------------------------------------------------------------------------------------------------------

iocpSocketUtils.pas

a: loadExFunctions生成的socket未close

-------------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------------------
TIocpAcceptExRequest.pas双链表示例：

1: 为TIocpAcceptorMgr类增加一个TIocpAcceptExRequest头连接

TIocpAcceptorMgr = class(xx)
private
  FAcceptRequestHead: TIocpAcceptExRequest;
end;  

2: 为TIocpAcceptExRequest两个字段前+后对象属性：

TIocpAcceptExRequest = class(...)
private
  FNextReq, FPrevReq: TIocpAcceptExRequest;  
end;

3：增加操作
procedure TIocpAcceptorMgr.checkPostRequest;
var
  lvRequest:TIocpAcceptExRequest;
begin
    if FList.Count > FMinRequest then Exit;

    // post request
    while FList.Count < FMaxRequest do
    begin
      lvRequest := TIocpAcceptExRequest.Create(FOwner);
      lvRequest.FClientContext := FOwner.getClientContext;
      lvRequest.FAcceptorMgr := self;
      
      lvRequest.PostRequest;
      
      //无需LIST，增加使用双链表方法
      //FList.Add(lvRequest);
      
      // 新增的结点，永远在最前面。下列是双链表的标准写法。
      lvRequest.FPrevReq := nil;
      Flocker.Enter;
      lvRequest.FNextReq := FAcceptRequestHead;
      if FAcceptRequestHead <> nil then
        FAcceptRequestHead.FPrevReq := lvRequest;      
      FAcceptRequestHead := lvRequest;
      Flocker.Leave;
    end;
end;
  
4: 删除操作：
procedure TIocpAcceptorMgr.removeRequestObject(pvRequest: TIocpAcceptExRequest);
begin
  FLocker.Enter;
  if pvRequest.FPrevReq <> nil then
  begin
    pvRequest.FPrevReq.FNextReq := pvRequest.FNextReq;
    if pvRequest.FNextReq <> nil then
      pvRequest.FNextReq.FPrevReq := pvRequest.FPrevReq;
  end else
  begin
    FAcceptRequestHead := pvRequest.FNextReq;
    if FAcceptRequestHead <> nil then
      FAcceptRequestHead.FPrevReq := nil;    
  end;
  //  FList.Remove(pvRequest);
  FLocker.Leave;
end;


5:循环问题：
原有方式是通过for i := 0 to list.count - 1 do 。。。
现：
procedure TIocpAcceptorMgr.notifyForDestory;
begin
var
  i:Integer;
  lvRequest:TIocpAcceptExRequest;
begin
  FLocker.Enter;
  lvRequest := FAcceptRequestHead;
  while lvRequest <> nil do
  begin
    lvRequest.FOwner := nil;
    lvRequest.FAcceptorMgr := nil;
    lvRequest := lvRequest.FNextReq;
  end;
  FLocker.Leave;
end;

基本操作如上。
其它问题：
判断某对象，是否已经存在于链表中，如在，则不增加，不删除，否则容易出现莫名错误，特别是多线程状态下。

我一般的作法是加标志位，如：Socket.Connected/Active: Boolean 字段来判断，如下：

function lock_cmp_exchange(cmp_val, new_val: Boolean; var target: Boolean): Boolean; overload;
asm
{$ifdef win32}
  lock cmpxchg [ecx], dl
{$else}
.noframe
  mov rax, rcx
  lock cmpxchg [r8], dl
{$endif}
end;

TIocpAcceptExRequest = class(...)
private
  FActive: Boolean;
  FNextReq, FPrevReq: TIocpAcceptExRequest;  
end;

FActive default = false ( in constructor)
checkPostRequest操作时，进行置true
在removeRequestObject时置false
如果在不确定，remove或add操作，是否会多次调用，则使用：
var
  done: Boolean;

// 检测是否未激活(not active)，如果是false，则置true, 并返回false,其它情况类似
done := lock_cmp_exchange(false, true, active);
if done then exit;

不过TIocpAcceptExRequest好像不需要此操作。

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
TIocpClientContext双链表：
TIocpClientContext = class(xx)
private
  FConnected: Boolean;
  FNextClient, FPrevClient: TIocpClientContext;

  FOnlineClient: TIocpClientContext;
end;

function addClientContext(pvObject:TIocpClientContext): Boolean;
var
  done: Boolean;
begin
  // 是否已加入
  done := lock_cmp_exchange(false, true, FConnected); 
  result := not done;
  if not result then exit;
  
  pvObject.FPrevClient := nil;
  FClientContextLocker.Enter;
  pvObject.FNextClient := FOnlineClient;
  if FOnlineClient <> nil then
    FOnlineClient.FPrevClient := pvObject;
  FOnlineClient := pvObject;
  FClientContextLocker.Leave;
end;


function removeClientContext(pvObject: TIocpClientContext): Boolean;
begin
  // 是否已删除
  result := lock_cmp_exchange(true, false, FConnected); 
  if not result then exit;
  
  FClientContextLocker.Enter;
  if pvObject.FPrevClient <> nil then
  begin
    pvObject.FPrevClient.FNextClient := pvObject.FNextClient;
    if pvObject.FNextClient <> nil then
      pvObject.FNextClient.FPrevClient := pvObject.FPrevClient;
  end else
  begin
  	FOnlineClient := pvObject.FNextClient;
  	if FOnlineClient <> nil then
  	  FOnlineClient.FPrevClient := nil;
  end;
  FClientContextLocker.Leave;  
end;

循环不用说
client := FOnlineClient;
while client <> nil do
begin
  //...
  client := client.FNextClient;
end;

查找：比较复杂点
TIocpTcpServer

function checkClientContextValid(const pvClientContext: TIocpClientContext):
这个函数，真心不建议这种参数context，而是以client.socket，这个数字值作为关键字

然后，以hash法子，进行查找：

const
  HASH_CLIENT = $FFFF + 1;
  
TIocpTcpServer = class
  client_count: Integer;
  
  client_hash: array [0..HASH_CLIENT  - 1] of TIocpClientContext;
end;

增加属性：
TIocpClientContext = class(xx)
private
  FConnected: Boolean;
  // 这两字段，用于在线链表
  FNextClient, FPrevClient: TIocpClientContext;
  // 这两字段，用于hash链表
  FNextHash, FPrevHash: TIocpClientContext;
  FOnlineClient: TIocpClientContext;
end;

add to hash list:
 
if addClientContext(client) then
begin
  // 以client.RawSocket为键值，将client加入到client_hash中
  client.FPrevHash := nil;
  FClientContextLocker.Enter;  
  client.FNextHash := client_hash[client.RawSocket and (HASH_CLIENT - 1)];
  if client.FNextHash <> nil then
    client.FNextHash.FPrevHash := client;
  FClientContextLocker.Leave;   
end;

remove client from hash:
var
  fd: TSocket;

fd := client.RawSocket;
if removeClientContext(client) then
begin
  
  FClientContextLocker.Enter;    
  if client.FPrevHash <> nil then
  begin
    client.FPrevHash.FNextHash := client.FNextHash;
    if client.FNextHash <> nil then
      client.FNextHash.FPrevHash := client.FPrevHash;
  end else
  begin
    client_hash[fd and (HASH_CLIENT - 1)] := client.FNextHash;
    if client.FNextHash <> nil then
      client.FNextHash.FPrevHash := nil;
  end;
  FClientContextLocker.Leave;
end;

--search:
function find_client(fd: TSocket; var pvClientContext: TIocpClientContext): Boolean;
var
  client: TIocpClientContext;
begin
  result := false;
  client := client_hash[fd and (HASH_CLIENT - 1)] ;
  while client <> nil do
  begin
    if client.RawSocket = fd then
    begin
      result := true;      
      pvClientContext := client;
      break;
    end;
    client := client.FNextHash;
  end;
end;

-- loop:
var
  i: Integer;
  client, next_client: TIocpClientContext;
begin
  for i := 0 to HASH_CLIENT - 1 do
  begin
     client := client_hash[i];
     while client <> nil do
     begin
       next_client :=  client.FNextHash;
       do_callback(client);
        ...;
  	   client := next_client;
     end;
  end;
end;

我一般写成：
TMyCallbackEvent = function (client: TClient): Boolean; // of object
TServer.Foreach(event: TMyCallbackEvent);
begin
  if not assigned(event) then exit;
  ..
  if not event(client)  then
    break;
  ..
end;
---------------------------------------------
没了。